#include <iostream>
#include <omp.h>

int a, b, rank;
float x = 0;

/*
Дериктива threadprivate означает, что в каждом потоке будут созданы
локальные копии переменных a и x. Тот факт, что данные переменные глобальные,
означает, что значения этих переменных будет сохраняться в каждом потоке на
протяжении нескольких параллельных секций.
*/
#pragma omp threadprivate(a, x)

int main() {
    /* Explicitly turn off dynamic threads */
    omp_set_dynamic(0);
    printf("======================\n");
    printf("first parallel section\n");
    printf("======================\n");

    /*
    Деректива private говорит о том, что не смотря на то, что переменные rank и b
    объявлены в глобальном scope, для ДАННОЙ ПАРАЛЛЕЛЬНОЙ СЕКЦИИ и для каждого потока
    эти переменные будут уникальные (их значение не будет перенесено в другие параллельные секции).
    */
    #pragma omp parallel private(b, rank)
    {
        rank = omp_get_thread_num();
        a = rank+1;
        b = rank;
        x = 1.1 * rank +1.0;
        printf("Thread %d:  a = %d, b = %d, x = %f\n", rank, a, b, x);
    }

    printf("\n");
    printf("=======================\n");
    printf("second parallel section\n");
    printf("=======================\n");
    
    x = 42.0;
    /*
    Заметим, что после первой параллельной секции значения переменных a и x
    сохранились в следующей параллельной секции. Причем, поскольку эти переменные 
    анотированы threadprivate, для каждого потока сохранилось свое значение переменной.
    Заметим так же, что для нулевого thread переменная x сохранила значение 42.0, а не
    1.0; это произошло, потому что в данном случае нулевой thread является master thread-ом,
    и он сохранил значение, которые мы присвоили переменной x в линейной области.

    Что же касается значения переменной b, поскольку в первой параллельной секции она 
    была анотирована private, то, хоть она и глобальная, но ее значения во второй 
    параллельной секции не имеют никакого отношения к ее значениям в первой секции.

    Обратим внимание, что если же мы попробуем запихнуть b в threadprivate, мы словим 
    ошибку компиляции из-за противоречия: переменная не может сохранять свое значение 
    на протяжении нескольких паралельных секций и при этом являться уникальной для 
    конкретной секции
    */
    #pragma omp parallel private(rank)
    {
        rank = omp_get_thread_num();
        printf("Thread %d:  a = %d, b = %d, x = %f\n", rank, a, b, x);
    }

    printf("\n");
    printf("======================\n");
    printf("third parallel section\n");
    printf("======================\n");

    x = 69.0;
    
    /*
    В третьей пареллельной секции, в отличие от второй, мы анотировали переменную x
    copyin, поэтому в каждой нити локальная копия этой переменной инициализировалась
    значение, которое мы присвоили ей в master потоке (то есть в параллельной области).
    */
    #pragma omp parallel private(rank) copyin(x)
    {
        rank = omp_get_thread_num();
        printf("Thread %d:  a = %d, b = %d, x = %f\n", rank, a, b, x);
    }
}

/*
Выводы:

- threadprivate применяется для глобальных переменных и создает в каждом потоке локальные 
копии этих переменных, причем их значения сохраняются для каждого потока на протяжении
всех параллельных секций.

- private создает в каждом потоке локальные копии указанных переменных, причем их значения
актуальны только на текущую параллельную секцию.

- copyin применяется к переменным, которые помечены, как threadprivate и в 
данной секции инициализирует их значениями из master-потока.
*/