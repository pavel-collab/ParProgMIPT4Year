# Умножение матриц

В работе исследованы различные алгоритмы для перемножения двух квадратных матриц ~~произвольных~~
почти произвольных размеров. Так же проводится сравнительных анализ этих алгоритмов между собой.

В работе представлены следующие алгоритмы:
- наивный алгоритм перемножения матриц
- алгоритм перемножения с оптимизацией кэша процессора
- распараллеленный наивный алгоритм (представлен с различными типами балансировки загрузки процессов, которые доступны в OpenMP)
- распараллеленный алгоритм с оптимизацией кэша
- алгоритм Штрассена
- алгоритм переменожения матриц с использованием векторизации в процессоре
- распараллеленный алгоритм переменожения матриц с использованием векторизации в процессоре

## Некоторые особенности реализации (for reviewers and developers)

Некоторые моменты реализации данной работы, связанные с хранением матриц, обращением к их элементам
и др. имеют свои особенности ~~просто автор работы -- человек альтернативно одаренный и по-другому не умеет~~. В этом разделе кратко освещены моменты, на которые стоит обратить внимание при чтении 
кода.

- содердимое матриц хранится в одномерных векторах стандартной библиотеки по строкам в соответствии с идеологией структуры виртуальнойпамяти в C. Обращение к элементам матрицы по 2 индексам происходит с использованием специально функции, конвертирующей 2 индекса в индекс одномерного вектора. Не исключено, что замена векторов стандартной библиотеки на обычные указатели ускорит код (автор этого не проверял).

- алгоритмы Штрассена и векторизации вынесены в отдельные файлы для удобства.

- в работе предусмотрен алгоритм генерирования случайного контента для заполнения матриц произваольного размера. Случайная матрица генерируется при каждом новом запуске программы.

- в работе предусмотрена система валидации результата умножения (см. раздел Инструкция по сборке и запуску)

- поскольку в работе необходимо исследовать множество различных случаев, было принято решение реализовать различное поведение кода не через аргументы командной строки, а через макросы. Макросы используются при компиляции (см. Makefile) и в завивсимости от их значения отрабатывает тот или иной участок кода.

## Краткие сведенья об оптимизации кэша

Как известно, содердимое двумерной матрицы хранится в виртуальной памяти в строчку в одномерном 
"массиве" (сначала хранится первая строка, потом вторая и т. д.). У процессора имеется кэш и при 
чтении из памяти он считывает не по одному значению, а целыми бачами (размер бача равен размеру 
кэша). Это сделано с расчетом на то, что когда пользователь обращается к i-й ячейке памяти, высока 
вероятность, что после этого он захочет обратиться к (i+1)-й ячейке, и процессор, таким образом 
уже хранит данное значение в кэше, поэтому считывание происходит быстрее.

При переменожении двух матриц i-я строка первой матрицы умножается скалярно на j-й столбец второй
матрицы, получая, таким образом, $c_{ij}$ -- элемент новой матрицы. Заметим, что в случае с первой 
матрицей кэш процессора работает прекрасно. Действительно матрица хранится в виртуальной памяти 
по строкам. При обращении к i-й строке процессор загружает в память целый кусок этой строки, с 
которым он потом работает. А вот со второй матрицей -- беда. Элементы одного столбца хранятся
в памяти не подряд, поэтому процессор не может загрузить их в кэш одной командой. Приходится 
постоянно обращаться к оперативной памяти (а это дольше, чем обращение к кэшу) -- происходят, так
называемые, кэш-промахи.

Для того, чтобы этого избежать, достаточно транспонировать вторую матрицу. В этому случае она 
будет храниться в памяти "по столбцам". Когда процессор загрузит в кэш линейный кусок памяти, это
будет часть столбца второй матрицы. При этом, в алгоритме умножения необходимо будет поменять 
местами индексы при обращении к элементам второй матрицы, ведь в памяти мы храним ее 
транспонированный вариант, а умножать хотим прямую матрицу. 

## Краткие сведенья о векторизации

## Алгоритм Штрассена

Алгоритм Штрассена -- алгоритм для перемножения матриц. По сравнению с другими алгоритмами, он
имеет доказанную ассимптотическую сложность $O(n^{2.8})$ вместо $O(x^3)$. За счет этого, он должен
выдавать лучший результат работы в плане времени. Однако, на практике реализация алгоритма на 
данный момент приостановлена. 

Ключевая проблема -- алгоритм является рекурсивным, основная идея заключается в том, что на каждом
этапе рекурсии исходные матрицы делятся на 4 части. При реализации алгоритма я выделял на каждую
часть отдельный вектор, то есть аллоцировал памял динамически, то есть производил обращение к куче,
так как обращение к куче является долгой операцией, то и алгоритм выдает наихудший результат.

## Иснтрукция по сборке и запуску эксперементов

Перейдите в рабочий каталог проекта. Работа предполагает несколько вариантов сборки:

- для валидации результата работы алгоритма
- для постановки эксперемента

### Валидация

Первый вариант сборки позволяет проверить каждый эксперемент на корректность работы. Результат 
работы алгоритма (матрица) сравнивается с результатом, полученным при перемножении матриц с 
помощью питоновских функций.

Для сборки выполните команду
```consol
make Validation
```

При этом в рабочем каталоге появятся бинарные файлы программы. Каждый файл запускается ОТДЕЛЬНО. 
Каждый файл соответсвует одному определенному алгоритму умножения матриц:

- simple_matrix_multiplication -- наивный алгоритм умножения матриц
- cache_friendly_matrix_multiplication  -- алгоритм умножения с использованием оптимизаций кэша
- parallel_simple_matrix_multiplication_static -- параллельный алгоритм умножения матриц
- parallel_cache_friendly_matrix_multiplication -- параллельный алгоритм умножения матриц с использованием оптимизаций кэша
- vectorized_matrix_multiplication -- алгоритм умножения матриц с использованием векторизации
- parallel_vectorized_matrix_multiplication -- параллельный алгоритм умножения матриц с использованием векторизации
- strassen -- алгоритм Штрассена

Для проверки алгоритма выберете соответсвующий файл и запустите его, передав в качестве аргумента
командной строки размер матрицы. Например:

```
./simple_matrix_multiplication 16
```

Эта команда сгенерирует 2 матрицы размером $16 \times 16$ и перемножит их наивным алгоритмом.
При этом, в рабочем каталоге появятся 3 файла .dat: matrix1.dat, matrix2.dat, 
multiplication_result.dat. В этих файлах записаны сгенерированные матрицы и результат их умножения.
Перейдите в каталог python и запустите из него скрипт Validation.py

```
python3 Validation.py
```

Этот скрипт использует файлы  matrix1.dat, matrix2.dat, multiplication_result.dat для проверки 
корректности результата (так же, вы можете самостоятельно перемножить матрицы из файлов matrix1.dat, matrix2.dat и сравнить ответ с multiplication_result). Если результат работы алгоритма 
корректный, вы увидите сообщение

```
[+] Success
```

После этого вернитесь в исходный каталог и ОБЯЗАТЕЛЬНО удалите все файлы .dat. Вы можете сделать
это вручную или использовать команду 

```
make clear_dat
```

### Эксперементы

При постановке эксперементов программы не записывают результат работы в файлы, а только фиксируют
время исполнения алгоритма.

Перейдите в рабочий каталог и удалите все бинарники от предыдущих запусков. Сделать это можно 
командой

```
make clear_bin
```

Соберите бинарники для постановки эксперементов

```
make
```

Перейдите в каталог python, запустите один из эксперементов и ожидайте результата
```
python3 Experiment.py
```

- Experiment1.py -- выводит сравнительный график времени работы всех алгоритмов в зависимости от размера матрицы.
- Eperiment2.py -- выводит сравнительный граифк времени работы параллельного алгоритма в зависимости от типа балансировки загрузки процессов.
- Experiment3.py -- выводит сравнительный график времени работы алгоритма Штрассена по сравнению с другими алгоритмами.

## Результаты эксперементов